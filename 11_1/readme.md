
# Домашнее задание к занятию "`Базы данных, их типы`" - `Девятов Илья`

### Задание 1. СУБД

**Решение**

1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.

Рекомендуемая СУБД: Реляционная (PostgreSQL, Microsoft SQL Server, Oracle)
Почему:

Требуется строгая структура данных (финансовые отчёты, бюджеты, прогнозы).
ACID-гарантии для корректности транзакций.
Поддержка сложных SQL-запросов для аналитики.

1.1.* Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?

Решение: Использовать Redis (как in-memory кэш) или специализированные API, например:
FastAPI (если хеширование происходит в приложении).
Memcached (если нужно кэшировать результаты хеширования).

1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.

Рекомендуемая СУБД:
Для лендингов: Документо-ориентированная (MongoDB, Firebase) – быстрое сохранение лидов.
Для CRM: Реляционная (PostgreSQL) или гибрид (MongoDB + PostgreSQL).

1.2.* Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?

Да, если:
Использовать PostgreSQL с JSONB (гибкость для лендингов + структура для CRM).
Или MongoDB (если CRM не требует сложных JOIN-запросов).

1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.
Рекомендуемая СУБД: Реляционная (PostgreSQL, SQLite) или Wiki-система (Confluence + база).
Почему: Простая структура, удобные связи между документами.

1.3.* Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?
Да:
Если уже есть PostgreSQL, создать отдельную схему (knowledge_base).
Если MongoDB, хранить как коллекцию документов с категориями.

1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.
Рекомендуемая СУБД: Графовая (Neo4j) или реляционная с геоданными (PostgreSQL + PostGIS).
Почему:
Графы лучше для маршрутизации (связи "точка A → точка B").
PostGIS – если важны геоданные и интеграция с другими системами.

1.4.* Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?
Лучше отдельную, но в связке:
Закупки: Реляционная СУБД (учёт материалов, поставщиков).
Логистика: Графовая или PostGIS.
Связь: API или общая БД (PostgreSQL) с разными схемами.

1.5.* Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?

Да, но с компромиссами:
PostgreSQL (лучший универсальный вариант):
Финансы – таблицы + аналитика.
CRM – JSONB для гибкости.
База знаний – отдельная схема.
Логистика – PostGIS для маршрутов.
Минус: Графовые запросы сложнее, чем в Neo4j.
Альтернатива:
MongoDB + PostgreSQL + Redis (оптимально по производительности).
Если нужна максимальная простота – только PostgreSQL.


### Задание 2. Транзакции

2.1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.
1 Инициация платежа
Пользователь вводит номер телефона и сумму пополнения в интерфейсе (мобильное приложение, сайт, USSD-меню).
Система проверяет корректность номера и минимальную/максимальную сумму.
2 Выбор способа оплаты
Пользователь выбирает источник списания (банковская карта, электронный кошелёк, мобильный платёж и т. д.).
3 Авторизация платежа
Платежный шлюз (например, CloudPayments, Tinkoff, Qiwi) запрашивает подтверждение:
Для карты: 3D Secure (SMS-код, биометрия).
Для электронных денег: вход в аккаунт.
4 Списание средств
Деньги резервируются/списываются с источника.
Платежная система генерирует уникальный ID транзакции.
5 Зачисление на счёт телефона
Оператор связи (МТС, Билайн и др.) получает запрос через API.
Баланс абонента увеличивается, система фиксирует время и сумму.
6 Подтверждение успеха
Пользователь получает SMS или push-уведомление о пополнении.
В истории платежей появляется запись (если есть ЛК).

2.1.* Какие действия должны произойти, если пополнение счёта телефона происходило бы через автоплатёж?
1 Подключение автоплатежа
Пользователь привязывает карту/кошелёк и настраивает условия (например, "пополнять на 500 ₽ при балансе < 50 ₽").
2 Триггер списания
Система оператора или банка проверяет баланс/дату (например, каждые 24 часа).
3 Автоматическая авторизация
Для карт: списание по токену (без повторного ввода CVC).
Для кошельков: фоновый запрос без подтверждения.
4 Обработка неудачи
Если оплата не прошла (например, недостаточно средств), система:
Отправляет уведомление.
Повторяет попытку через N часов (если настроено).
5 Уведомление
SMS/email о списании и новом балансе (даже если автоплатёж был фоновым).
Ключевое отличие:
При обычном платеже инициатива на стороне пользователя, при автоплатеже – автоматическая проверка условий + фоновое списание.

### Задание 3. Преимущества NewSQL перед SQL и NoSQL

Задание 3. SQL vs NoSQL
3.1. Напишите пять преимуществ SQL-систем по отношению к NoSQL.
1 Строгая структура данных (схемы)
Чёткие таблицы, связи и ограничения (NOT NULL, UNIQUE, FOREIGN KEY).
Исключаются дублирование и аномалии данных.

2 Гарантии ACID (целостность транзакций)
Атомарность (всё или ничего), согласованность, изолированность, долговечность.
Критично для финансовых, медицинских и государственных систем.

3 Мощные аналитические возможности
Сложные JOIN-запросы, оконные функции (OVER, PARTITION BY), агрегации.
Оптимизация для отчётов и BI-инструментов (Power BI, Tableau).

4 Универсальность и стандартизация
Единый язык (SQL) для всех реляционных СУБД (PostgreSQL, MySQL, Oracle).
Огромное сообщество и документация.

5 Безопасность и контроль доступа
Гибкие роли (GRANT, REVOKE), шифрование, аудит изменений.
Поддержка GDPR, HIPAA и других стандартов.

3.1.* Какие, на ваш взгляд, преимущества у NewSQL систем перед SQL и NoSQL.

NewSQL (CockroachDB, Google Spanner, YugabyteDB) — гибрид, сочетающий:
Масштабируемость NoSQL (шардирование, распределённые кластеры).
ACID-транзакции SQL (горизонтальное масштабирование без потери целостности).

1. Производительность при росте нагрузки
Автоматическое шардирование, как в NoSQL, но с поддержкой JOIN и сложных запросов.

2. Глобальная согласованность
Работа с распределёнными данными (например, сервера в разных странах) без потерь (в отличие от eventual consistency в NoSQL).

3. Упрощённый переход с традиционных SQL
Совместимость с PostgreSQL/MySQL (меньше переписывания кода).

4. Отказоустойчивость
Репликация и самовосстановление (как в Cassandra или MongoDB), но с гарантиями ACID.

5. Поддержка облачных и гибридных сред
Оптимизация для Kubernetes, облачных провайдеров (AWS, GCP).

Пример использования:
Финансовые приложения, где нужны:
Горизонтальное масштабирование (как у NoSQL).
Транзакции между континентами (как у Spanner).
SQL-синтаксис для миграции с Legacy-систем.

Недостатки NewSQL:
Меньше зрелости, чем у PostgreSQL/Oracle.
Сложность настройки кластера.

### Задание 4. Преимущества NewSQL перед SQL и NoSQL
Критерии выбора СУБД:
1 Тип данных и workload:
Структурированные данные + сложные запросы → NewSQL (CockroachDB, YugabyteDB) или MPP-СУБД (Greenplum).
Полуструктурированные/гибкие схемы → NoSQL (MongoDB, Cassandra).
Графовые связи → Neo4j (если нужен анализ зависимостей).

2 Масштабируемость:
Горизонтальное шардирование (автоматическое распределение данных по узлам).
Поддержка линейного роста (1000+ машин).

3 Консистентность vs. Доступность:
Strong Consistency (финансы, транзакции) → NewSQL.
Eventual Consistency (логи, аналитика) → NoSQL (Cassandra, ScyllaDB).

4 Скорость обработки:
OLTP (много коротких транзакций) → NewSQL.
OLAP (аналитика) → Columnar DB (ClickHouse, Vertica).

5 Интеграция с экосистемой:
Поддержка Spark, Kafka для потоковой обработки.
Совместимость с облачными хранилищами (S3, HDFS).

Лучшая модель распределённых вычислений:
1. MapReduce (Hadoop) + Spark
Плюсы:
Обработка петabyte-scale данных.
Отказоустойчивость (перерасчёт при сбоях).
Минусы: Высокая задержка (не для real-time).
Пример: Пакетная аналитика, ETL-процессы.

2. MPP (Massively Parallel Processing)
Примеры: Greenplum, ClickHouse, Snowflake.
Плюсы:
Мгновенные SQL-запросы на больших данных.
Колоночное хранение для аналитики.
Минусы: Сложность администрирования.

3. Actor Model (Akka, Orleans)
Для: Высоконагруженных real-time систем (игры, IoT).
Плюсы: Минимальные задержки.
Минусы: Нет встроенной работы с данными.

4. Dataflow (Apache Flink, Beam)
Для: Потоковой обработки (real-time аналитика).
Пример: Мониторинг транзакций, фрод-детекция.

Итоговое решение:
Критерий	Выбор
Тип данных	Структурированные + аналитика
СУБД	ClickHouse (OLAP) или CockroachDB (OLTP + NewSQL)
Модель вычислений	MPP + Spark для баланса скорости и масштаба
Инфраструктура	Kubernetes + S3-хранилище
Почему?

ClickHouse (если нужна сверхбыстрая аналитика на 1000 узлах).
CockroachDB (если важны транзакции + SQL-совместимость).
Spark надстройкой для сложных ETL.
Альтернатива для NoSQL:
Cassandra + Spark (если данные слабоструктурированы).
ScyllaDB (если нужна скорость > 1M ops/sec).



